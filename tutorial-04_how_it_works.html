<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Tutorial: 04. How it works</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Tutorial: 04. How it works</h1>

    <section>

<header>
    

    <h2>04. How it works</h2>
</header>

<article>
    <p><link rel="stylesheet" href="./vs.css"></p>
<p><link rel="stylesheet" href="./api.css"></p>
<script src="./highlight.pack.js" type="text/javascript"></script>
<script>hljs.initHighlightingOnLoad();console.log("initHighlightingOnLoad")</script>


<h2>Basic Operation</h2><p>The high-level flowchart shows the three distinct phases of operation:</p>
<ol>
<li>Initialisation - runs only once at startup and loads data into memory that will be required to handle each request</li>
<li>Handling user input - sanitising and deciding what to do with it, including constructing the SQL query</li>
<li>Handling the data - including querying the database and formatting the output data and sending to user</li>
</ol>
<p>The core of the system is the module, called <strong>querify</strong> that constructs the SQL query based on the user input. This is described in a separate flowchart below.</p>
<p><img src="API_program_flow.png" alt="how it works" title="how it works"></p>
<h2>Startup</h2><h3>Server Configuration</h3><p>On startup, the API reads in data that is used for handling incoming requests. There are two main sources of this data:</p>
<ul>
<li><strong>qs_specification_all.json</strong> configuration file</li>
<li>the database (provides a list of all tables)</li>
</ul>
<h4>Query string specification (all)</h4><p>This contains configuration settings for the system, SQL template information for each dataset and specifications for each query string to allow input sanitisation and security-checking.<br>It is made up of the following elements:</p>
<ul>
<li><strong>static_html</strong> Detailed HTML fragments for constructing the home page of the site that is generated by the system.</li>
<li><strong>html</strong> Very simple/prescriptive HTML fragments for automatically generating a website based on a simple templating system included.</li>
<li><strong>sql</strong> SQL template information: fields to use (including derived or calculated fields); ordering and other details.</li>
<li><strong>generic</strong> Acceptable query strings and values or value-ranges; default/fallback values to use if omitted and necessary to include; indicators if multiple values are allowed or if parameter is optional; mutex data.</li>
<li><strong><em>[multiple]</em></strong> Acceptable query strings and values as per <em>generic</em>, named exactly as the database table they refer to.</li>
</ul>
<h5>Query string top-level</h5><p>These are the basic elements, empty here, of the qs_specification_all.json file.</p>
<pre><code class="json hljs">
{
   "static_html":{},
   "html":{},
   "sql":{},
   "generic":{},
   "energy_dukes":{},
   "business_bpe":{}
}
</code></pre>

<h5>HTML templates</h5><p>There is a primitive templating system that generates content for the home page and landing pages.
The elements in blue are static - that is, they are always going to look like that. 
The orange and red sections are dynamically generated: in this context that just means they 
reflect a potentially variable number of links, and the entire sections are independent of each other.
This means the home page contains all sections, but the <strong>business</strong> landing page contains only 
links to business pages, and similarly for <strong>energy</strong>.</p>
<p><img src="home_page_markup.png" alt="HTML template areas" title="HTML template areas"></p>
<h6>Static landing page html template</h6><p>As the name suggests, this is not going to change much. Each tag contains a chunk of HTML which is strung together with other information by the API code. 
For instance, between the <code>page_header_1</code> and <code>page_header_2</code> elements, the page title is inserted by the code, and so on.</p>
<p>The ga_script tag contains the Google Analytics tracker code that is inserted on the home page and is made available for other pages to also automatically insert.
If the UA-id were to change, for instance, this is the place to edit that.</p>
<p>(Note: The content of the elements below have been shortened for readability)</p>
<pre><code class="json hljs">
   "static_html":{
      "page_header_1":"&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;",
      "page_header_2":"&lt;/title&gt;&lt;/head&gt;",
      "body_start":"&lt;body&gt;...",
      "logo_url":"/business/data/images/BEISlogo-portrait-colour.png",
      "body_start2":"&lt;div class=\"row\"&gt;",
      "body_start3":"&lt;/div&gt;",
      "body_1":"&lt;p&gt;Various beta ... &lt;/p&gt;",
      "body_2":"&lt;hr&gt;&lt;h4&gt;BEIS data tools feedback&lt;/h4&gt;&lt;p&gt;Please email... &lt;/p&gt;",
      "ga_script":"&lt;script&gt;(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject'];... &lt;/script&gt;"
   },
</code></pre>


<h6>HTML listing</h6><p>These apply to the main home page and the section landing pages (i.e. energy, business). They are used to create a directory listing of all the UI pages that have been created.
Note: they do not actually create these pages, nor if they prevent a page being accessed if an entry here is missing. This information is only used in making the page listing. </p>
<pre><code class="json hljs">
   "html":{
      "energy":{
         "dukes":{
            "title":"Digest of UK Energy Statistics",
            "page_data":[
               {
                  "page":"dukes",
                  "name":"Data downloader",
                  "blurb":"This allows users to download DUKES data in a quick and flexible manner.",
                  "uri":"/data/",
                  "public_link":true
               },
               {
                  "page":"index",
                  "name":"Application Programming Interface (API) instructions",
                  "blurb":"This allows advanced users to download data by entering a URL in a specific format.",
                  "uri":"/manual/",
                  "public_link":true
               }
            ]
         }
      },
</code></pre>

<p>This section is within the <code>html</code> object.</p>
<p>The object keys of this object are the section names, as they appear in the URL - e.g. <code>energy</code> and <code>business</code> and are created for each section as needed. 
The values of these object keys are objects that contain details to fill in the template:</p>
<ul>
<li><code>title</code> [String] the section title to display on the landing pages</li>
<li><code>page_data</code> [Object] the details to fill in to each link template for all the pages necessary<ul>
<li><code>page</code> [String] the page filename stem, i.e the filename without any .html etc.</li>
<li><code>name</code> [String] the text to display in the link</li>
<li><code>blurb</code> [String] any text to display following the link for any additional info</li>
<li><code>uri</code> [String] the URI fragment, using the section name as root, that this link appends to lead to the actual page</li>
<li><code>public_link</code> [Boolean] a flag that controls whether or not to display the link - useful for preparing a link in advance but suppressing it until it is time to publish. (A future feature could be to add a publication date/time that enables automatic publication)</li>
</ul>
</li>
</ul>
<h5>SQL templates</h5><p>Each database table will most likely have different fields. These are specified here, along with some other basic SQL actions such as sort-order.</p>
<pre><code class="json hljs">
      "energy_dukes":{
         "title": "DUKES Balances",
         "description": "The most important table in DUKES...",
         "fields":[
            "item",
            "display_order",
            "concat_ws(':', replace(format('%' || 3 || 's', fuel_ref), ' ', '0'), fuel_type) AS fuel",
            "year",
            "energy",
            "unit",
            "src"
         ],
         "rename":{

         },
         "display":{

         },
         "sql_order":" ORDER BY year, fuel_ref, display_order ",
         "hierarchy":{
            "fuel":"fuel",
            "flow":"flow",
            "fuel_field":"fuel_ref",
            "flow_field":"id_name",
            "flow_detail":"display_order",
            "fuel_detail":"fuel_ref"
         }
      },
</code></pre>

<p>This section is within the <code>sql</code> object.
The object keys of this object are database table names e.g. <code>energy_dukes</code> and are required for each main table (i.e. not the data dimension tables).
The values of these object keys are objects that contain generic details to construct the SQL statement:</p>
<ul>
<li><code>fields</code> [Array] the fields to include in the SQL output. Note that constructed fields are permitted</li>
<li><code>rename</code> [Object] currently does nothing - reserved for future use. Just include <code>{}</code></li>
<li><code>display</code> [Object] alternative fieldnames for use depending on whether you want machine readable output or the more human friendly labels. For instance, in BPE, this specifies : {&quot;sizeband&quot;: {&quot;label&quot;: &quot;sizeband_label&quot;}, &quot;region&quot;: {&quot;label&quot;: &quot;region_label&quot;} } meaning that the entry in the <code>sizeband_label</code> field of the database is also returned for use as an alternative to the more cryptic <code>sizeband</code> code (and similarly for <code>region</code>. The effect is when constructing the SQL query, these fields are also included: <code>SELECT year,region_label,region,sizeband_label,sizeband,value FROM business_bpe</code></li>
<li><code>sql_order</code> [String] a fragment of a SQL statement indicating the fields to order by</li>
<li><code>hierarchy</code> [Object] this is used for situations when there are several fields necessary to hold both a text reference and numeric id to a concept. This is an optional structure, and simpler datasets can do without it, but when used, it consists of a triplet <strong>&quot;xxxx&quot;</strong>, <strong>&quot;xxxx_field&quot;</strong>, <strong>&quot;xxxx_detail&quot;</strong> for instance in ECUK, the fuel dimension is recorded as: <code>{&quot;fuel&quot;: &quot;fuel&quot;, &quot;fuel_field&quot;: &quot;fuel_name&quot;, &quot;fuel_detail&quot;: &quot;fuel_id&quot;}</code>. The first pair consists of the key, <em>&quot;fuel&quot;</em>, i.e. the dimension name, which happens to have a value that is also <em>&quot;fuel&quot;</em>, i.e. the field (in the database) holding the names/ids the user sends in the API query. It is recorded in case they need to differ for some reason. The second pair denotes the field to use for a textual representation of a dimension element, so for the fuel dimension it is <code>&quot;fuel_field&quot;: &quot;fuel_name&quot;</code>, indicating that the _&quot;fuel_name&quot;_ field has a nice text representation that can be used for display purposes. The third set <code>&quot;fuel_detail&quot;: &quot;fuel_id&quot;</code> indicates the field containing the id of that item. This is the field that is used for the final SQL query, and is found in the <strong>_ref_order_</strong> field in the corresponding dimension table  (it is called ref_order because originally it was used for sorting as well as being a unique ID).</li>
</ul>
<p>Also included here is some descriptive data on each table listed:</p>
<ul>
<li><code>title</code> [String] a helpful title of the table for display purposes</li>
<li><code>description</code> [String] information on the data in that table, where it might be used etc.</li>
</ul>
<h5>User input sanitisation parameters: generic</h5><p>These parameters will be applied to all user input regardless of which table the user is querying</p>
<p>Note: in the first entry below for format in the generic section, the acceptable types are listed as including yaml and xml.
These have been removed in the production version, although the code still exists to process these. 
The main reason for this is that for some reason, linebreaks appear as &quot;\n&quot; in the output instead of true linebreak characters.
However, XML generation is extremely slow, so it's good to not support it in the first place.</p>
<p>The generic parameters are:</p>
<table>
    <tr>
        <th>parameter</th><th>description</th>
    </tr>
    <tr><td>format</td><td>the file format to output</td></tr>
    <tr><td>style</td><td>whether to output human- or machine-readable data</td></tr>
    <tr><td>limit</td><td>maximum number of records to return, exactly as a standard SQL LIMIT command (TOP in MS Sequel Server)</td></tr>
    <tr><td>offset</td><td>where to start the records from, as per standard SQL LIMIT command</td></tr>
    <tr><td>count</td><td>not implemented in code - feature to get counts of a particular attribute - as per SQL COUNT(*) </td></tr>
    <tr><td>fields</td><td>a list of fields the user wishes to use, overriding the standard defaults</td></tr>
    <tr><td>exclude_fields</td><td>a list of fields the user wishes to exclude Note: if both fields and exclude_fields are present, fields will take precedence</td></tr>
    <tr><td>orientation</td><td>whether to return the data in &quot;narrow&quot; i.e. database format, or &quot;wide&quot; i.e. pivoted spreadsheet columnar format</td></tr>
    <tr><td>output</td><td>whether to only return figures that have been revised or suppressed (included for completeness, as it will only return a &quot;*&quot;)</td></tr>
    <tr><td></td><td></td></tr>
</table>


<p>Each parameter has the following standard attributes:</p>
<table>
    <tr>
        <th>attribute</th><th>description</th>
    </tr>
    <tr><td>type</td><td>Indicates what type of parameter this is - something that affects SQL or is it something else?</td></tr>
    <tr><td>min</td><td>The minimum number acceptable (integer types only)</td></tr>
    <tr><td>max</td><td>The maximum number acceptable (integer types only)</td></tr>
    <tr><td>acceptable</td><td>All the input values that will be accepted can be enumerated here. For some inputs, this makes no sense, such as for integers, in which case there are other checks.</td></tr>
    <tr><td>sql_ignore</td><td>Lists values you want the user to be able to specify, but that should not actually be included in the query. This includes terms such as &quot;original&quot;, &quot;all&quot;. These are useful descriptors for users, but the database will return all values anyway unless restricted, so suppressing this part of the query does what is required. This would not normally be specified explicitly by a user, but is necessary when constructing a user interface widget like a radio button.</td></tr>
    <tr><td>fallback</td><td>A default value to use if nothing is supplied</td></tr>
    <tr><td>range</td><td>Helpful if an integer parameter is part of a range of values. If range is 0 it implies this is the lower bound of a range (and ' &gt;= ' is used); if 1, it is the upper bound (and ' &lt;= ' is used)</td></tr>
    <tr><td>multiple</td><td>Sometimes it makes sense to provide several values in a list (comma separated), in which case this attribute should be <b>true</b></td></tr>
    <tr><td>purpose</td><td>This indicates whether this attribute is used when creating the SQL: <code>sql</code>, controling the output format: <code>output</code>, or something else</td></tr>
    <tr><td>mutex</td><td>This identifies mutally exclusive attribute pairings. It is a list (array) of other attributes this should not appear with. For example, to specify a single year, use the <code>year</code> attribute - but doing this makes specifying <code>year_start</code> and <code>year_end</code> redundant, so is disallowed. This attribute does not need to be provided if not applicable.</td></tr>
    <tr><td>required</td><td>Indicates whether the API needs this information, not whether to reject request that don't include this. If the user fails to supply anything for a required field, the fallback value is used instead.</td></tr>
    <tr><td>acceptable_postfix</td><td>For sort parameters, the fieldname indicated to sort on can have '_A' or '_D' appended indicating ascending or descending sort order. No other character may be appended, unless this value is included here. This is inadvisable unless the code is also edited.</td></tr>
</table>


<pre><code class="json hljs">
   "generic":{
      "format":{
         "type":"string",
         "acceptable":["csv", "json", "yaml", "xml"],
         "fallback":"json",
         "multiple":false,
         "purpose":"output",
         "required":true
      },
      "style":{
         "type":"sql_control_s",
         "acceptable":["h", "m", "a"],
         "fallback":"h",
         "multiple":false,
         "purpose":"sql",
         "required":true
      },
      "limit":{
         "type":"sql_control_i",
         "min":1,
         "fallback":"ALL",
         "multiple":false,
         "purpose":"sql",
         "required":true
      },
      "offset":{
         "type":"sql_control_i",
         "min":0,
         "fallback":0,
         "multiple":false,
         "purpose":"sql",
         "required":true
      },
      "count":{
         "type":"sql_control_i",
         "min":1,
         "fallback":99999,
         "multiple":false,
         "purpose":"sql",
         "required":true
      },
      "fields":{
         "type":"sql_control_s",
         "acceptable":[1],
         "fallback":"all",
         "multiple":true,
         "purpose":"sql",
         "mutex":[
            "exclude_fields"
         ],
         "required":false
      },
      "exclude_fields":{
         "type":"sql_control_s",
         "acceptable":[1],
         "fallback":"none",
         "multiple":true,
         "purpose":"sql",
         "mutex":[
            "fields"
         ],
         "required":false
      },
      "orientation":{
         "type":"string",
         "acceptable":["narrow", "wide"],
         "fallback":"narrow",
         "multiple":false,
         "purpose":"output",
         "required":true
      },
      "output":{
         "type":"string",
         "acceptable":["normal", "all", "suppressed", "revised", "missing"],
         "fallback":"all",
         "multiple":false,
         "purpose":"sql",
         "required":false
      }
   },
</code></pre>


<h5>User input sanitisation parameters: custom</h5><p>There will be some inputs that will be specific to a particular table. These can be handled in a section whose name is that of the table to which the setting apply:</p>
<p>Note 1: The <strong>mutex</strong> (mutually exclusive) item lists the other query strings that cannot be present in the same query as that one.
For instance, if there is a <strong><em>year</em></strong> query string, indicating a single year, then <strong>_year_start_</strong> and <strong>_year_end_</strong> cannot also be present.
Note 2: <strong>aggregation</strong> contains many acceptable inputs. However, only &quot;absolute&quot; has been implemented in the code. Using any of the others will be ignored. Treat these as a suggestion for future development work!</p>
<pre><code class="json hljs">
   "energy_dukes":{
      "year_start":{
         "type":"integer",
         "min":1998,
         "max":2017,
         "fallback":2017,
         "range":0,
         "multiple":false,
         "purpose":"sql",
         "mutex":["year"],
         "required":true
      },
      "year_end":{
         "type":"integer",
         "min":1998,
         "max":2017,
         "fallback":2017,
         "range":1,
         "multiple":false,
         "purpose":"sql",
         "mutex":["year"],
         "required":true
      },
      "year":{
         "type":"integer",
         "min":1998,
         "max":2017,
         "fallback":2017,
         "multiple":true,
         "purpose":"sql",
         "mutex":["year_start", "year_end"],
         "required":true
      },
      "resolution":{
         "type":"sql_control_s",
         "acceptable":["full", "medium", "aggregate", "exact"],
         "fallback":"exact",
         "multiple":false,
         "purpose":"sql",
         "required":true
      },
      "unit":{
         "type":"string",
         "acceptable":["GWh", "ktoe", "mtonnes"],
         "sql_ignore":["original", "all"],
         "fallback":"all",
         "multiple":true,
         "purpose":"sql",
         "required":true
      },
      "sort":{
         "type":"sort",
         "acceptable":[
            "item",
            "display_order",
            "fuel_type",
            "fuel_ref",
            "year",
            "energy",
            "unit",
            "status",
            "src"
         ],
         "acceptable_postfix":[
            "A",
            "D"
         ],
         "fallback":[
            {
               "sort_field":"display_order",
               "sort_direction":"A",
               "fallback":true,
               "priority":999
            }
         ],
         "multiple":false,
         "purpose":"sql",
         "required":false
      },
      "aggregation":{
         "type":"aggregation",
         "acceptable":[ "sum", "mean", "average", "mode", "median", "count", "max", "min", 
                "stddev", "variance", "negative", "absolute"],
         "target":"energy",
         "fallback":"sum",
         "multiple":false,
         "purpose":"sql",
         "required":false
      },
      "pivot_variable":{
         "type":"string",
         "acceptable":["fuel"],
         "fallback":"fuel",
         "multiple":false,
         "purpose":"output",
         "required":true
      },
      "pivot_value":{
         "type":"string",
         "acceptable":["energy"],
         "fallback":"energy",
         "multiple":false,
         "purpose":"output",
         "required":true
      }
   },
</code></pre>



<h4>Database table naming</h4><p>There is a strict naming convention applied to the database tables:</p>
<ul>
<li>all names are lowercase only</li>
<li>any table whose name begins with a double underscore '__' is private and is ignored by the API</li>
<li>any table whose name begins with a single underscore '_' is protected and is recognised by the API, but has no data served up by it. This is for possible future use and is not curently used.</li>
<li>the table name is divided up based on single underscores '_' between name elements:<ul>
<li>The first element denotes the section (usually 'energy' or 'business')</li>
<li>the second element denotes the dataset (e.g. 'dukes', 'bpe')</li>
<li>the third element, if present, denotes a dimension to the table indicated by the first and second elements (so 'energy_dukes_flow' is the flow dimension of 'energy_dukes')</li>
</ul>
</li>
</ul>
<h2>Input: request handling</h2><h3>Request routing</h3><p>The user requests data from the API by entering terms into the API as indicated in the <a href="tutorial-03_getting_data.html">Anatomy of an API request</a>).<br>The dataset is selected in the <kbd class="route">route</kbd> section of the query. Knowing this, the dimensions can be selected and then everything in the <kbd class="type">type</kbd> section of the query is checked against these for an exact match. </p>
<div class="warning">
The separation of the terms in the URL into the basic parts is handled by regular expressions. This was built into the routing mechanism of restify v6 and earlier, but because regular expressions are quite CPU-intensive, they have been removed from restify v7 onwards in favour of a simpler mechanism that works for most API standards such as OpenAPI/Swagger. As a precaution, restify is therefore frozen at v6 until the impact of this can be determined, and what to do about it.
</div>  

<p>The standard way of handling routing is known as <a href="http://sinatrarb.com/intro.html">Sinatra</a> routing after the web framework that introduced(?) it. Here, the main handler for valid queries looks like this:</p>
<pre><code class="js">
server.get(/^\/([a-zA-Z0-9_\.~-]+)\/([a-zA-Z0-9_\.~-]+)\/(.*)/, function(req, res, next) {
    try{
        dispatch_route(req, res, next);
    } catch(err) {handle_error(err)}
    return next();
});
</code></pre>



<h3>Dispatch</h3><p>The raw request object is passed into the <code>dispatch_route</code> function. The first thing this does is check the first two route parameters and checks that the request contains a valid dataset and a valid table belonging to that dataset. If the dataset doesn't exist, it just produces a cryptic error message <code>'D, nothing here!'</code>. If a table (in this context that means a table containing the main data for a dataset - not simply a database table) doesn't exist, it checks this parameter to see if it is a dimension table, in which case it looks like the user wants metadata about the dimension, either in a tree structure, or flat data (the next parameter indicates this - either &quot;tree&quot; or &quot;flat&quot;). If neither table nor dimension metadata appear to be requested, it generates another cryptic error message <code>'T, nothing here!'</code>.<br>However, if all is good, it passes the input parameters to the appropriate place for handling. This may be to <code>sanitize_input</code> for a regular query, or if metadata is requested, this is already held in memory so is passed straight back for output.  </p>
<h3>Input sanitisation</h3><p>There are two stages in checking user input:</p>
<ol>
<li>Identify obviously bad requests such as hacking attempts. This is based on some of the most common observed attempts. It is meant as a pre-processing step to deal with obviously bad queries and reduce the processing burden on the server. Examples include anything ending in &quot;.php&quot; or starting with &quot;admin.&quot;. These are handled by the <code>blackhole</code> function, which ensures the attempt is logged separately but nothing is returned to that user (not even a 404 error) as to reduce own system burden whilst leaving their system waiting until it times out. Also this denies them the benefit of any information about the system that can be used.<div class="warning">
This is not to be relied upon for stopping all hacking attempts - it is only for reducing system burden for the most common ones
</div></li>
<li>Check the remaining input against the whitelisted acceptable inputs in the preferences file: <strong>qs_specification_all</strong> (read: <em>query sting specification for all datasets</em>). This is done in the  <code>sanitize_input</code> function. By this stage, the routes and query string parts of the URL have been parsed and are contained in the raw_routes and raw_qs parameters. The remaining parameter (<code>dataset_ref</code>) contains all the dimensions of that particular dataset to check against.<br>The output contains all the details necessary for further processing, including constructing the SQL query and formatting the output:<ul>
<li>table_name</li>
<li>good_routes </li>
<li>bad_routes </li>
<li>good_query_strings </li>
<li>bad_query_strings</li>
<li>missing_query_strings  </li>
</ul>
</li>
</ol>
<h3>Query construction</h3><p>At its core is the module that takes all the cleaned user input parameters and figures out what to do with them.</p>
<p>It treats the routes and query strings slightly differently, but in either case, it works out how they need to be used in the final SQL statement.</p>
<p>Any non-SQL parameters are separated out and passed back for use downstream. It makes sense to do this here as the work is already being done, so we might as well use these outputs rather than do it all again.</p>
<p><img src="querify_program_flow.png" alt="query construction" title="query construction"></p>
<h2>Output: data handling</h2><h3>Data dispatch</h3><p>Once the SQL statement has been constructed, it is a trivial matter to query the database. This is still handled within the <code>dispatch_route</code> function. At this point, there is a commented out call to a <code>post_process</code> stub function (i.e. it does nothing). This is where any other processing could be carried out on the data. Bear in mind that if it is likely to slow down the user query, it should probably not be implemented here.  </p>
<p>The data returned from the database is passed into <code>configure_data_for_output</code>, which formats this data - for instance pivoting dataframe from narrow to wide, but also looks after making into csv/json/yaml/html format.  </p>
<div class="warning">
The code for creating YAML and XML output has been left in the API. It is prevented from ever being called by excluding 'yaml' and 'xml' from the acceptable output format list in qs_specification_all.json. This has been done for performance reasons. XML is particularly slow. If the impact on the server of reenabling these is acceptable, then doing so is simply a matter of adding 'yaml' and/or 'xml' to the list.
</div>
</article>

</section>

</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Querify.html">Querify</a></li><li><a href="module-Shapeshifter.html">Shapeshifter</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-01_introduction.html">01. Introduction</a></li><li><a href="tutorial-02_installation.html">02. Installation</a></li><li><a href="tutorial-03_getting_data.html">03. Using the API to get data</a></li><li><a href="tutorial-04_how_it_works.html">04. How it works</a></li><li><a href="tutorial-05_data_structure.html">05. Data structures</a></li><li><a href="tutorial-06_preparing_data.html">06. Preparing stats data for the API</a></li><li><a href="tutorial-07_server.html">07. Updating live server</a></li><li><a href="tutorial-08_ui_landing.html">08. UIs: landing pages</a></li><li><a href="tutorial-09_ui_dd.html">09.  UIs: data downloader</a></li><li><a href="tutorial-10_ui_graphs.html">10. Other UI possibilities: graphs</a></li><li><a href="tutorial-11_a1.html">Annex 1: Design Principles</a></li><li><a href="tutorial-12_a2.html">Annex 2: Engineering Principles</a></li><li><a href="tutorial-13_a3.html">Annex 3: Future Developments</a></li><li><a href="tutorial-14_a4_graphs.html">Annex 4: Graph Examples</a></li></ul><h3>Global</h3><ul><li><a href="global.html#end_timer">end_timer</a></li><li><a href="global.html#finalise_response">finalise_response</a></li><li><a href="global.html#format_yaml">format_yaml</a></li><li><a href="global.html#get_datasets">get_datasets</a></li><li><a href="global.html#normalizePort">normalizePort</a></li><li><a href="global.html#onError">onError</a></li><li><a href="global.html#onListening">onListening</a></li><li><a href="global.html#output_404">output_404</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Mon Jan 13 2020 17:36:08 GMT+0000 (Greenwich Mean Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>